## Week 4 - Day 1

### Basics of the Unix Philosophy

The ‘Unix philosophy’ originated with Ken Thompson's early meditations on how to design a small but capable operating system with a clean service interface. It grew as the Unix culture learned things about how to get maximum leverage out of Thompson's design. It absorbed lessons from many sources along the way.

- Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new features.
- Expect the output of every program to become the input to another, as yet unknown, program. Don't clutter output with extraneous information. Avoid stringently columnar or binary input formats. Don't insist on interactive input.
- Design and build software, even operating systems, to be tried early, ideally within weeks. Don't hesitate to throw away the clumsy parts and rebuild them.
- Use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you've finished using them.



**Print Odd & Even Number from 1-20**

- Basic Increments https://codepen.io/nrupuld/pen/PrQxYm?editors=1011
- Basic Increments (Params) https://codepen.io/nrupuld/pen/wLyQaP?editors=1011
- Looping Modulus https://codepen.io/nrupuld/pen/gNvQPR?editors=1011
- Looping Modulus Single Function https://codepen.io/nrupuld/pen/vqdQXg?editors=1011
- Looping Modulus Generalised Function https://codepen.io/nrupuld/pen/rEJQjE?editors=1011
- Looping Modulus Generalised Abstraction https://codepen.io/nrupuld/pen/vqdQem?editors=1011

